// Import the logger package
import 'package:logger/logger.dart';
// Import the dart:async library for asynchronous operations
import 'dart:async';
// Import the dart:convert library for JSON encoding/decoding
import 'dart:convert';
// Import the dart:io library for input/output operations
import 'dart:io';
// Import the postgres package for PostgreSQL database interaction
import 'package:postgres/postgres.dart';
// Import the firebase_stuff file
import 'package:qore_server_postgres/firebase_stuff.dart';
// Import the qore_server_postgres_funcs file
import 'package:qore_server_postgres/qore_server_postgres_funcs.dart';

// Define an enum for available commands
enum Commands {
  addPatient,
  getPatientsByIdDoc,
  getPatientsByLastName,
  getPatientById,
  updatePatient,
  deletePatient,
  lockPatient,
  rollback,
  pong,
}

// Initialize a logger instance
var logger = Logger(
  printer: PrettyPrinter(
      methodCount: 2,
      // number of method calls to be displayed
      errorMethodCount: 8,
      // number of method calls if stacktrace is provided
      lineLength: 120,
      // width of the output
      colors: true,
      // Colorful log messages
      printEmojis: false,
      // Print an emoji for each log message
      printTime: true // Should each log print contain a timestamp
      ),
);

// Initialize a logger instance without stack trace
var loggerNoStack = Logger(
  printer: PrettyPrinter(methodCount: 0),
);

// Main function
void main() async {
  // Set the logging level to trace
  Logger.level = Level.trace;

  // Read the certificate and private key files
  final certificate = File('vcsinc_certificate.pem').readAsBytesSync();
  final privateKey = File('vcsinc_private_key.pem').readAsBytesSync();

  // Declare a security context
  late final SecurityContext context;

  // Clod: volver a probar con los vencidos y bajar el servidor.
  try {
    // Initialize the security context
    context = SecurityContext()
      ..useCertificateChainBytes(certificate)
      ..usePrivateKeyBytes(privateKey);
  } catch (e) {
    // Print any errors that occur during security context initialization
    print(e);
    // Exit the program
    exit(42);
  }

  // Bind the server to the specified address and port
  final server = await HttpServer.bindSecure(InternetAddress.anyIPv4, 8080, context);
  // Log that the server is running
  logger.i('WebSocket server running on ${server.address}:${server.port}', time: DateTime.now());

  // Listen for incoming HTTP requests
  await for (HttpRequest request in server) {
    // Declare a firebase token
    String firebaseToken;
    // Open a connection to the DB per http connection (one connection per client)
    final postgresConnection = PostgreSQLConnection('localhost', 5432, 'qore', username: 'postgres', password: 'root');
    // Open the database connection
    await postgresConnection.open();
    

    // Check if the request is a WebSocket upgrade request
    if (WebSocketTransformer.isUpgradeRequest(request)) {
      // Upgrade the request to a WebSocket connection
      var socket = WebSocketTransformer.upgrade(request).then((webSocket) async {

        // Set a timeout for the server
        server.timeout(Duration(seconds: 10),onTimeout: (_){ logger.d("timeout");} );

        // Log that a WebSocket connection was established
        logger.i('WebSocket connected', time: DateTime.now());

        // Function to handle timeout ping
        handleTimeoutPing() async {
          try {
           // logger.d("Enviando ping", time: DateTime.now());
            // responseMessage = 'ping';
           // webSocket.add('ping');
          } catch (e) {
            // Log that the ping could not be sent
            logger.d("No pude enviar el ping", time: DateTime.now());
            // Print the error
            print(e);
          }
        }

        // Function to handle timeout pong
        handleTimeoutPong() {
          // No hubo respuesta al útlimo ping.
          // Log that the client is dead
          logger.f("El cliente is dead", time: DateTime.now());
        }

        // Define a Maximum inactive timer for the client
        Duration pingInterval = Duration(seconds: 60);
        Duration maxInactivityInterval = Duration(seconds: 60);
        // Create a timer for ping
        Timer pingTimer = Timer(pingInterval, handleTimeoutPing);
        // Create a timer for pong
        Timer pongTimer = Timer(maxInactivityInterval, handleTimeoutPong);

        // Infinite loop waiting for messages
        await for (var message in webSocket) {

          // Message arrived,reset timers.
          pingTimer.cancel();
          pongTimer.cancel();
          // Create a new timer for ping
          pingTimer = Timer(pingInterval, handleTimeoutPing);

          // Convert the message to a list of int
          List<int> intList = message.toString().split(',').map((str) => int.parse(str)).toList();

          // Initialize the response message
          String responseMessage = "";

          // Extract action
          int qoreAction = intList[0];
          // Log the received action
          logger.d("Received action: $qoreAction = ${Commands.values[qoreAction]}", time: DateTime.now());

          // Extract message length
          int messageLength = intList[1] * 255 + intList[2];

          // Initialize the decoded message
          String decoded = '';

          // Extract action
          int action = intList[0];
          // Log the received action
          logger.d("Accion recibida: $action = ${Commands.values[action]}");

          // Check if the message length matches the data length
          if (intList.sublist(3).length == messageLength) {
            // Decode from UTF8 list to String
            decoded = utf8.decode(intList.sublist(3));
            // Log the received data
            logger.d("Received data: $decoded", time: DateTime.now());
          }

          // Check if the message length matches the data length
          if (intList.sublist(3).length == messageLength) {
            // Process command
            var decodedMessage = utf8.decode(intList.sublist(3));
            // Split the decoded message
            var decoded = decodedMessage.split("|")[1];
            // Get the firebase token
            firebaseToken = decodedMessage.split("|")[0];
            // Log the received token
            logger.t("El token recibido es: $firebaseToken");

            // Validate the firebase token
            bool validToken = await validateUserFirebaseToken(firebaseToken);

            // If the token is valid
            if (validToken) {
              // Log the decoded message
              logger.t("La decodificación del mensaje recibido es: $decoded", time: DateTime.now());

              // Process the command
              if (action == Commands.getPatientsByLastName.index) {
                responseMessage = await getPatientsByLastName(decoded, postgresConnection);
              } else if (action == Commands.getPatientsByIdDoc.index) {
                responseMessage = await getPatientsByIdDoc(decoded, postgresConnection);
              } else if (action == Commands.getPatientById.index) {
                responseMessage = await getPatientById(decoded, postgresConnection);
              } else if (action == Commands.addPatient.index) {
                responseMessage = await addPatient(decoded, postgresConnection);
              } else if (action == Commands.updatePatient.index) {
                responseMessage = await updatePatient(decoded, postgresConnection);
              } else if (action == Commands.pong.index) {
                // Log that a pong was received
                logger.d("Pong recibido", time: DateTime.now());
                // Envío otro ping y lanzo timer. Si recibo pong el cliente está
                // vivo y, si no, es que murió.
                responseMessage = "ping";
                // Create a new timer for pong
                pingTimer = Timer(maxInactivityInterval, handleTimeoutPong);
              } else if (action == Commands.rollback.index) {
                try {
                  // Rollback the transaction
                  await postgresConnection.execute("ROLLBACK");
                } catch (e) {
                  // Log that there was no transaction in course
                  logger.d("No había transacción en curso", time: DateTime.now());
                }
              } else {
                // Log that an unknown command was received
                logger.i("Comando desconocido recibido", time: DateTime.now());
                // Rollback the transaction
                await postgresConnection.execute("ROLLBACK");
              }
            } else {
              // Set the response message to unauthorized
              responseMessage = "Usuario no autorizado";
            }
            // Send answer to client
            sendResponse(responseMessage, webSocket);
          }
        }
      });
    }
  }
}

// Function to send a response to the client
void sendResponse(String responseMessage, WebSocket webSocket) {
  // Log the response message
  logger.d("Response message to be enconded: $responseMessage");
  // Encode the response message
  final encodedMessage = utf8.encode(responseMessage);
  // Get the length of the encoded message
  final length = encodedMessage.length;
  // Calculate the low byte of the length
  final lengthL = length % 255;
  // Calculate the high byte of the length
  final lengthH = (length / 255).truncate();
  // Create the header
  final header = [0x01, lengthH, lengthL];
  // Create the answer frame
  final answerFrame = [...header, ...encodedMessage];
  // Log that the response is being sent
  logger.i("Sending response back to client");
  // Add the answer frame to the WebSocket
  webSocket.add(answerFrame);
}

/*
Future<void> createRecord(Map<String, dynamic> payload, PostgreSQLConnection connection) async {
  final name = payload['name'];
  final age = payload['age'];

  await connection.query('INSERT INTO users (name, age) VALUES (@name, @age)', substitutionValues: {'name': name, 'age': age});
}

Future<void> readRecord(Map<String, dynamic> payload, WebSocket webSocket, PostgreSQLConnection connection) async {
  final id = payload['id'];

  final result = await connection.query('SELECT name, age FROM users WHERE id = @id', substitutionValues: {'id': id});

  if (result.isNotEmpty) {
    final user = result[0];
    final name = user[0];
    final age = user[1];

    final response = {'name': name, 'age': age};
    webSocket.add(json.encode(response));
  }
}

Future<void> updateRecord(Map<String, dynamic> payload, PostgreSQLConnection connection) async {
  final id = payload['id'];
  final name = payload['name'];
  final age = payload['age'];

  await connection
      .query('UPDATE users SET name = @name, age = @age WHERE id = @id', substitutionValues: {'id': id, 'name': name, 'age': age});
}

Future<void> deleteRecord(Map<String, dynamic> payload, PostgreSQLConnection connection) async {
  final id = payload['id'];

  await connection.query('DELETE FROM users WHERE id = @id', substitutionValues: {'id': id});
}
*/
